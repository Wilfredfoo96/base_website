import { defineSchema, defineTable } from 'convex/server'
import { v } from 'convex/values'

export default defineSchema({
  // Existing users table
  users: defineTable({
    clerkId: v.string(),
    firstName: v.optional(v.string()),
    lastName: v.optional(v.string()),
    email: v.string(),
    imageUrl: v.optional(v.string()),
    bio: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
    lastSignInAt: v.optional(v.number()),
    isAutoGenerated: v.optional(v.boolean()),
  })
    .index('by_clerk_id', ['clerkId'])
    .index('by_email', ['email'])
    .index('by_created_at', ['createdAt'])
    .index('by_auto_generated', ['isAutoGenerated']),

  // Orders - Core order management
  orders: defineTable({
    orderId: v.string(),
    customerId: v.string(),
    customerName: v.string(),
    customerPhone: v.string(),
    status: v.union(
      v.literal('PENDING_DISPATCH'),
      v.literal('PENDING_VERIFICATION'),
      v.literal('PROCESSING'),
      v.literal('ASSIGNED'),
      v.literal('EN_ROUTE'),
      v.literal('DELIVERED'),
      v.literal('FAILED'),
      v.literal('RETURNED'),
      v.literal('CANCELLED')
    ),
    paymentMethod: v.union(v.literal('COD'), v.literal('BANK_TRANSFER')),
    paymentStatus: v.union(
      v.literal('PENDING'),
      v.literal('VERIFIED'),
      v.literal('REJECTED')
    ),
    paymentProofUrl: v.optional(v.string()),
    totalAmount: v.number(),
    items: v.array(
      v.object({
        productId: v.string(),
        productName: v.string(),
        quantity: v.number(),
        unitPrice: v.number(),
        subtotal: v.number(),
      })
    ),
    deliveryAddress: v.object({
      label: v.optional(v.string()),
      street: v.string(),
      city: v.string(),
      state: v.string(),
      zipCode: v.string(),
      coordinates: v.object({
        lat: v.number(),
        lng: v.number(),
      }),
      instructions: v.optional(v.string()),
    }),
    deliveryNotes: v.optional(v.string()),
    assignedDriverId: v.optional(v.string()),
    routePosition: v.optional(v.number()),
    proofOfDeliveryUrl: v.optional(v.string()),
    failedReason: v.optional(v.string()),
    returnReason: v.optional(v.string()),
    cancelledAt: v.optional(v.number()),
    cancellationReason: v.optional(v.string()),
    cancelledBy: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
    verifiedBy: v.optional(v.string()),
    verifiedAt: v.optional(v.number()),
    searchTokens: v.string(),
  })
    .index('by_status', ['status'])
    .index('by_paymentStatus', ['paymentStatus'])
    .index('by_driverId', ['assignedDriverId'])
    .index('by_customerId', ['customerId'])
    .index('by_createdAt', ['createdAt'])
    .index('by_search', ['searchTokens']),

  // Drivers - Driver management
  drivers: defineTable({
    driverId: v.string(),
    clerkId: v.string(),
    name: v.string(),
    phone: v.string(),
    isOnDuty: v.boolean(),
    currentLocation: v.optional(
      v.object({
        lat: v.number(),
        lng: v.number(),
        timestamp: v.number(),
      })
    ),
    codWallet: v.number(),
    lastLocationUpdate: v.optional(v.number()),
    createdAt: v.number(),
  })
    .index('by_clerkId', ['clerkId'])
    .index('by_isOnDuty', ['isOnDuty']),

  // Products - Product catalog
  products: defineTable({
    productId: v.string(),
    name: v.string(),
    description: v.optional(v.string()),
    price: v.number(),
    sku: v.string(),
    imageUrl: v.optional(v.string()),
    stockLevel: v.number(),
    category: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index('by_sku', ['sku'])
    .index('by_category', ['category']),

  // Routes - Route/Manifest management
  routes: defineTable({
    routeId: v.string(),
    driverId: v.string(),
    orderIds: v.array(v.string()),
    status: v.union(
      v.literal('DRAFT'),
      v.literal('ACTIVE'),
      v.literal('COMPLETED')
    ),
    createdAt: v.number(),
    startedAt: v.optional(v.number()),
    completedAt: v.optional(v.number()),
  })
    .index('by_driverId', ['driverId'])
    .index('by_status', ['status']),

  // Audit Logs - Security and tracking
  auditLogs: defineTable({
    logId: v.string(),
    action: v.union(
      v.literal('PAYMENT_APPROVED'),
      v.literal('PAYMENT_REJECTED'),
      v.literal('ORDER_ASSIGNED'),
      v.literal('ORDER_STATUS_CHANGED'),
      v.literal('ROUTE_CREATED'),
      v.literal('ROUTE_OPTIMIZED'),
      v.literal('DRIVER_SETTLED'),
      v.literal('STOCK_RESTOCKED'),
      v.literal('PRODUCT_CREATED'),
      v.literal('PRODUCT_UPDATED'),
      v.literal('ORDER_CANCELLED')
    ),
    adminId: v.string(),
    targetId: v.string(),
    metadata: v.optional(v.any()),
    timestamp: v.number(),
  })
    .index('by_adminId', ['adminId'])
    .index('by_timestamp', ['timestamp'])
    .index('by_targetId', ['targetId'])
    .index('by_action', ['action']),

  // Customers - Customer information
  customers: defineTable({
    customerId: v.optional(v.string()), // Made optional for migration
    clerkId: v.string(),
    name: v.optional(v.string()), // Made optional for migration
    email: v.string(),
    phone: v.optional(v.string()), // Made optional for migration
    // Legacy fields for backward compatibility
    firstName: v.optional(v.string()),
    lastName: v.optional(v.string()),
    imageUrl: v.optional(v.string()),
    totalOrders: v.optional(v.number()),
    updatedAt: v.optional(v.number()),
    savedAddresses: v.optional(
      v.array(
        v.object({
          addressId: v.string(),
          label: v.string(),
          street: v.string(),
          city: v.string(),
          state: v.string(),
          zipCode: v.string(),
          coordinates: v.object({
            lat: v.number(),
            lng: v.number(),
          }),
          isDefault: v.optional(v.boolean()),
          createdAt: v.number(),
        })
      )
    ),
    createdAt: v.number(),
  })
    .index('by_clerkId', ['clerkId'])
    .index('by_email', ['email']),

  // Settings - System configuration
  settings: defineTable({
    key: v.string(),
    value: v.any(),
    updatedAt: v.number(),
    updatedBy: v.optional(v.string()),
  }).index('by_key', ['key']),
})
